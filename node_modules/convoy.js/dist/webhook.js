"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Webhook = void 0;
var errors_1 = require("./utils/errors");
var crypto = require('crypto');
var Webhook = /** @class */ (function () {
    function Webhook(options) {
        this.defaultOptions = {
            DEFAULT_TOLERANCE: 300,
            DEFAULT_ENCODING: 'hex',
            DEFAULT_HASH: 'sha256',
        };
        this.payload = options.payload;
        this.header = options.header;
        this.secret = options.secret;
        this.tolerance = options.tolerance || this.defaultOptions.DEFAULT_TOLERANCE;
        this.hash = options.hash || this.defaultOptions.DEFAULT_HASH;
        this.encoding = options.encoding || this.defaultOptions.DEFAULT_ENCODING;
    }
    Webhook.prototype.verify = function () {
        var signedHeader = this.parseSignatureHeader();
        if (!signedHeader.signatures.length) {
            throw new errors_1.WebhookVerificationException('Webhook has no valid signature');
        }
        var message;
        if (signedHeader.isAdvanced) {
            message = "".concat(signedHeader.timestamp, ",").concat(JSON.stringify(this.payload));
        }
        if (!signedHeader.isAdvanced) {
            message = JSON.stringify(this.payload);
        }
        var expectedSignature = crypto
            .createHmac(this.hash, this.secret)
            .update(message, 'utf8')
            .digest(this.encoding);
        return this.validateComputedSignature(signedHeader.signatures, expectedSignature);
    };
    Webhook.prototype.parseSignatureHeader = function () {
        var header = this.header;
        if (typeof header !== 'string') {
            throw new errors_1.WebhookVerificationException('Webhook has invalid header');
        }
        var signature = {
            timestamp: -1,
            signatures: [],
            isAdvanced: false,
        };
        var parts = header.split(',');
        signature =
            parts.length > 1 ? this.decodeAdvanced(signature, parts) : this.decodeSimple(signature, this.header);
        return signature;
    };
    Webhook.prototype.decodeAdvanced = function (sh, pairs) {
        pairs.map(function (sig) {
            var item = sig.split('=').slice(1).join('=');
            if (isNaN(Number(item))) {
                // We're not dealing with a timestamp at this point
                sh.signatures.push(item);
            }
            else {
                sh.timestamp = parseInt(item, 10);
            }
        });
        if (!sh.timestamp || sh.timestamp === -1) {
            throw new errors_1.WebhookVerificationException('Webhook has invalid header');
        }
        var timestampAge = Math.floor(Date.now() / 1000) - sh.timestamp;
        if (timestampAge > this.tolerance) {
            throw new errors_1.WebhookVerificationException('Timestamp has expired');
        }
        sh.isAdvanced = true;
        return sh;
    };
    Webhook.prototype.decodeSimple = function (sh, header) {
        sh.signatures.push(header);
        return sh;
    };
    Webhook.prototype.validateComputedSignature = function (signatures, expectedSignature) {
        var _this = this;
        var signatureFound = signatures.filter(function (signature) {
            return _this.secureCompare(signature, expectedSignature);
        });
        if (!signatureFound.length) {
            throw new errors_1.WebhookVerificationException('Webhook has no valid signature');
        }
        return true;
    };
    Webhook.prototype.secureCompare = function (a, b) {
        a = Buffer.from(a);
        b = Buffer.from(b);
        if (a.length != b.length) {
            return false;
        }
        return crypto.timingSafeEqual(a, b);
    };
    return Webhook;
}());
exports.Webhook = Webhook;
